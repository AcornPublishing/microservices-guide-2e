# 22 Recipe: Tracing with Zipkin {#chapter-tracing}

In a distributed system, it may be necessary to track the path of a
request across the microservices. This is done by tracing.

The topics in this chapter are:

* The chapter explains the definition of tracing and in which
  situations tracing is useful.

* The chapter shows a concrete example of the tracing of a
  microservices system with Zipkin.

* The chapter also indicates alternatives to Zipkin for tracking
  requests across the microservices.

## 22.1 Basics {#section-tracing-grundlagen}

Microservices are a distributed system. Microservices call each
other. A problem with a microservice can be caused by the fact that
one of the called microservices does not work or takes too long to
respond to a request.

Tracing is particularly useful when microservices call each other. But
also the calls of a database or an external system can add useful
information to tracing.

#### Is Tracing Necessary?

Calls between microservices should be the exception in a microservices
system. Too many calls between the microservices lead to an overhead
caused by the communication over the network and thus to poor
performance. In addition, when a call is made between microservices,
the potential problem must be dealt with that the call might fail due
to a problem with the network or the called server. This makes such
systems difficult to operate.

Such systems are also problematic in regards to maintenance because
the calls represent dependencies between the microservices. If a
microservice needs to be changed, this can be a challenge because of
the dependencies. It is possible that other microservices may also
have to be changed. In this case, also several microservices must be
deployed, and coordinated deployment is required.

Ultimately, such a system violates the rule that modules should have
high cohesion but loose coupling. A lot of communication indicates a
tight coupling.

Tracing is especially important for synchronous communication. The
definition of synchronous communication allows a request to trigger
another request. So there are true call trees.
In
asynchronous communication, a request can only trigger another
request if it does not wait for a response. As HTTP always sends a
response, it is basically impossible for a request to cause another
request so cascades that require tracing do not really occur.

## 22.2 Tracing with Zipkin {#section-tracing-zipkin}

[Zipkin](http://zipkin.io/) is a tool for tracing. It has a server to
which the tracing data can be sent. In addition, the data can also be
displayed with the UI.

#### Zipkin: Structure

{id="fig-tracing-aufbau", width=66%}
![Fig. 22-1: Tracing Structure](images/tracing-aufbau.png)

[Figure 22-1](#fig-tracing-aufbau) shows the structure of Zipkin. As
*reporters*, the microservices pass data to Zipkin with the help of a
*transport*. Transport can be HTTP or Kafka. In order not to influence
the performance of the system too much, the data is sent
asynchronously by the reporters to the Zipkin server.

If a microservices call another microservice, the called microservices
also sends data through the transport to the server. That way data
about the cascading requests can be stored by the Zipking server.

In the *Zipkin server*, the *collector* receives the data and stores
it in *storage*. This can be a system like Cassandra, Elasticsearch,
or MySQL. The *API* provides access to the data and can run queries on
the data.
The user can analyze the data with the
*UI*.

#### Trace and Span ID

To trace the path of a call across the microservices, each call must
be assigned a unique *trace ID*. This trace ID must be transferred
with the subsequent calls.  For each call and each other measured time
span there is another unique identifier: a *span ID*.

These concepts are not limited to REST, but can also be used with
other communication protocols.

#### Tracing in the Example

{id="fig-tracing-beispiel"}
![Fig. 22-2: Tracing in the Example](images/tracing-beispiel.png)

[Figure 22-2](#fig-tracing-beispiel) shows how tracing works in the
example.

When the call arrives at the *order microservice*, the trace ID is
generated. All calls to *customer* and *catalog* generated by the same
call
to *order* have the same trace ID. Each call to *customer* or
*catalog* then has its own span ID.

{id="fig-tracing-data"}
![Fig. 22-3: Handling Tracing Data](images/tracing-data.png)

[Figure 22-2](#fig-tracing-data) shows what happens with the data:
Trace ID and span ID are sent to the Zipkin
server. The trace and span ID is also stored in the logs so that log
entries
can also be searched for trace IDs to find all logs for a specific
call to the system.

[Spring Cloud Sleuth](https://cloud.spring.io/spring-cloud-sleuth/)
offers a very easy way to integrate Zipkin into a Spring Boot
application. It ensures that trace IDs and span IDs are generated and
forwarded during communication. It also transfers the trace data to
the Zipkin server.

{id="fig-tracing-zipkin"}
![Fig. 22-4: Example with Zipkin](images/tracing-zipkin.png)

[Figure 22-4](#fig-tracing-zipkin) shows a trace where the order
microservice calls the catalog and the customer microservice. The
trace shows how much time is spent in the individual services.

{id="fig-tracing-dependencies", width=66%}
![Fig. 22-5: Dependencies with Zipkin](images/tracing-dependencies.png)

Zipkin can also visualize the dependencies in the system
([Figure 22-5](#fig-tracing-dependencies)). For a complex system, this
can be helpful to get an overview of the interactions of the
microservices.

## 22.3 Example {#section-tracing-beispiel}

The Consul example project has an extension (see also
[chapter 15](#chapter-consul)) that integrates Zipkin into the example
project with Spring Cloud Sleuth. In Java projects a
dependency to
`spring-cloud-starter-zipkin` has to be added. Afterwards, the
environment variable
`SPRING_ZIPKIN_ENABLED` can be used to enable support for Zipkin and
`SPRING_ZIPKIN_BASE_URL` can be used to configure the URL of the
Zipkin server. These settings are made in the file
`docker-compose-zipkin.yml` so that Docker Compose passes them on to
the microservices.
See [appendix C](#anhang-docker) for more details on Docker,
docker-compose and how to troubleshoot them.

The property `spring.sleuth.sleuth.sampler.percentage` in the file
`application.properties` of the microservices projects is set to the
value 1.0 so that each span is forwarded to the Zipkin server. In a
production system, this can be too much data. Since many calls are
identical, it a lower value may be enough. The default
is 0.1 so that 10% of all spans are stored on the server. The IDs
appear in
the logs regardless of the set value.
So it is still possible to find all log data from all microservices
that belong to a specific request.

#### How to Run the Example

[Section 0.4](#section-einleitung-quick-start) describes which
software has to be installed for starting the example.

First download the project with `git
clone https://github.com/ewolff/microservice-consul.git`. Afterwards,
you have to compile the application with Maven. To do so, you have to
compile the code with `./mvnw clean package` (macOS, Linux) or
`mvnw.cmd clean package` (Windows) in the sub directory
`microservice-consul-demo`.
See [appendix B](#anhang-maven) for more details on Maven and how to
trouble shoot the build.

Subsequently, you can generate the Docker containers in sub directory
`docker` with `docker-compose -f docker-compose-zipkin.yml build`. The
configuration in file `docker-compose-zipkin.yml` contains in addition
to the normal system configuration a Docker container for the Zipkin
server and switches on support for Zipkin.  With `docker-compose -f
docker-compose-zipkin.yml up -d` you can start the application with
Zipkin.

Afterwards you can use the order microservice, and with Zipkin you can
trace a call across several systems.

For this purpose, a Zipkin Docker container is configured in the
Docker Compose configuration. It is available at port 9411 of the
Docker host, i.e. at <http://localhost:9411> if the Docker
containers are running on the local computer.

At
<https://github.com/ewolff/microservice-consul/blob/master/HOW-TO-RUN.md>
you can find detailed instructions for building and starting the example.
 <https://github.com/ewolff/microservice-consul/blob/master/HOW-TO-RUN.md#run-the-zipkin-example>
explains how Zipkin can be added to the example.

## 22.4 Recipe Variations {#section-tracing-variationen}

Integration at UI level does not require tracing. With a UI
integration, it is transparent which part of the UI belongs to which
microservice. This makes troubleshooting relatively easy.

Zipkin supports many additional
[libraries and frameworks](http://zipkin.io/pages/existing_instrumentations.html)
so that tracing is also possible in a heterogeneous system.

Spring Cloud Sleuth can also be used so that only the
[trace IDs are transferred](http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/1.2.5.RELEASE/single/spring-cloud-sleuth.html#_only_sleuth_log_correlation). If
the trace ID is also stored in the logs, then at least all log
information for a request can be correlated in the log analysis.

An alternative to Zipkin is
[Jaeger](https://www.jaegertracing.io/). It supports
[OpenTracing](http://opentracing.io/) which
standardizes tracing data formats and instrumentations.
Istio is a service mesh and integrates many technologies that are
useful for operating microservices. [Section
23.5](#section-service-mesh-tracing) discusses Jaeger and its
integration in Istio.

Commercial systems for monitoring such as
[Dynatrace](https://www.dynatrace.com/platform/offerings/dynatrace/),
[New Relic,](https://newrelic.com/) or
[AppDynamics](https://www.appdynamics.com/) offer similar features for
also monitoring distributed systems.

## 22.5 Conclusion {#section-tracing-fazit}

Tracing makes it possible to track calls across microservices. For
synchronous microservices ([chapter 13](#chapter-synchron)) tracing is
especially useful if the microservices communicate a lot with each
other. However, too much communication should be avoided in a
microservices architecture because it is a sign of too many
dependencies, which also have a detrimental effect on changeability
and performance. In spite of the high demands placed on the operation
of microservices, tracing is not absolutely necessary when the
architecture is good enough to handle most requests in a single microservice.

The alternative to Zipkin is mainly consolidated logging
([chapter 21](#chapter-log-analyse)) with a trace ID for each
request. In this case, no special server is needed for
tracing. Instead, only the trace ID has to be transferred in each
request.

#### Advantages

* With Spring Cloud Zipkin is easy to integrate into the
  infrastructure.

* Zipkin allows extensive analyses.

* The correlation between log entries also makes logs easier to
  analyze.

#### Challenges

* Tracing is only necessary when the dependencies between the
  components are complex.

* Infrastructure for tracing has to be set up and operated.
