# 7 Concept: Frontend Integration {#chapter-frontend}

This chapter explains how microservices can be integrated in the web
frontend.

* First, the chapter discusses *why* the web frontend of a microservices
architecture should be modularized.

* *Single page apps (SPA)* are difficult to modularize.

* *ROCA (resource-oriented client architecture)* is an approach for web
  UIs which supports modularization.

* Furthermore, the chapter conveys which *options* there are for
  integration.
  
* Finally, *benefits* and *disadvantages* of the different integration
  options are discussed.

Thus, the chapter demonstrates how frontend integration can be
implemented and for which scenarios this is the best approach.

## 7.1 Frontend: Monolith or Modular? {#section-frontend-monolith}

[Figure 7-1](#fig-frontend-monolith) shows a frontend monolith which serves as
frontend for multiple microservices.

{id="fig-frontend-monolith"}
![Fig. 7-1: Frontend Monolith with Microservices Backend](images/frontend-monolith.png)

#### Option: Monolithic Frontend and Backend

It is inconsistent to do without modularization in the frontend. On
the one hand, there is a backend that is modularized into
microservices. This involves a great deal of effort, e.g. for
operation. On the other side is a monolithic frontend. Such an
architecture must be questioned. The result does not necessarily have
to be a modularized frontend. It may also turn out that a monolithic
frontend together with a monolithic backend also meets the
requirements. Then you can save the effort for the modularization of
the backend into microservices. This can be the case, for example, if
the advantage of separate deployment and further decoupling in other
areas (see [section 1.2](#section-microservices-gruende)) is not so important
after all.

[Figure 7-2](#fig-frontend-backend-monolith) shows a frontend monolith
which serves as frontend for a monolithic backend.

{id="fig-frontend-backend-monolith"}
![Fig. 7-2: Frontend Monolith with Backend Monolith](images/frontend-backend-monolith.png)

#### Option: Modularly Developed Frontend

Of course, a frontend that is deployed as a monolith can be developed
modularly.  Unfortunately, experience shows that modular development
often still leads to an unmaintainable, non-modular system in the end
because the boundaries between the modules dissolve over time. The
boundaries between modules that can be deployed separately, such as
microservices, are not so easy to circumvent so that modularization is
secured in the long term.

Nevertheless, each microservice can, for example, be assigned a module
in the frontend in order to decouple and parallelize the
development. However, in that case the frontend monolith still has to
be deployed as a whole. Separate deployment is the advantage of
microservices over other modularizations.

[Figure 7-3](#fig-frontend-module-im-frontend) shows a frontend
monolith which is divided into modules.

{id="fig-frontend-module-im-frontend"}
![Fig. 7-3: Frontend Monolith Divided into Modules](images/frontend-module-im-frontend.png)

#### Reasons for a Frontend Monolith

A frontend monolith can be a good choice in some circumstances.

* *Native mobile applications* or *rich client applications* are
  always deployment monoliths. They can only be delivered as a whole.
  Mobile applications even need to pass a review process in the app
  store in case of an update, so deployment takes even
  longer. However, this mechanism can be "undermined" to a certain
  extent. An app can display web pages. These can be provided by a
  microservices system that uses web frontend integration. Frameworks
  such as [Cordova](https://cordova.apache.org/) even allow web
  applications to take advantage of proprietary mobile phone features
  or to offer a web application for download from the app store. This
  means that compromises can be implemented between native
  applications and web applications.
  
* *Single page apps (SPAs)* can also only be deployed as a whole.
  There are enough alternatives to SPAs for web applications to
  completely modularize an application in the frontend. The boundaries
  are fluid. SPAs can contain links to other sites or other SPAs and
  display HTML generated by a different system. In this way, SPAs can
  be integrated in the frontend. But in practice, SPAs typically lead
  to a frontend deployment monolith despite these theoretical
  possibilities.

* If there is *a team* that deals with frontend development, this can
  be a reason to develop a monolithic frontend. Each team should be
  responsible for one component. If you do not want to break up the
  frontend team because it is too big an organizational change or
  because the team is working in a different location than the other
  teams, a monolithic frontend can be the best approach.

* Finally, it is possible that the *migration* of an existing system
  is particularly easy if the monolithic frontend remains intact.

#### Modularized Frontend

The alternative to a monolithic frontend is a fully modularized
frontend.  [Figure 7-4](#fig-frontend-modular) shows a modularized
frontend, where each microservice has its own frontend. Like the
backend, the frontend is part of the separately deployable
microservices. Such a modularization of the frontend has many
advantages. [Section 2.1](#section-mikro-makro-bounded-context) has
shown that microservices and self-contained systems can be independent
concerning their domain logic. If the microservices contain a part of
the modularized frontend, then a change in a domain can be implemented
by modifying and deploying just one microservice, even if changes are
necessary at the frontend. If the UI is a monolith, on the other hand,
many changes to the domain logic will require modifications to the UI
monolith so that the UI monolith becomes a main focus of change.

{id="fig-frontend-modular"}
![Fig. 7-4: Modularized Frontend](images/frontend-modular.png)

#### Modularized Frontend and Frontend Integration

To combine the separately deployed frontends into a complete system, the
frontends must be integrated.  Modularization is intended to decouple
development. Nevertheless, an integrated system must be created.  In
other words, a frontend that is modularized into different
microservices is only possible if an approach for frontend integration
has been chosen. For this, different technical approaches are
possible, which are the focus of this and the following chapters.

## 7.2 Options {#section-frontend-optionen}

There are different options for frontend integration. 

* The easiest option are *links*. One frontend displays a link which
  another frontend handles. The World Wide Web (WWW) is based on just
  this mechanism. A system creates a link to another system.

* *Redirects* represent another option. For example, OAuth2 uses this
  approach. A website provides a link to an OAuth2 provider such as
  Facebook
  or Google. The user enters his or her password and confirms that the
  website is allowed to access certain information. The user is then
  redirected back to the original website by another redirect. Behind
  the
  scenes, the website receives the user's data. Redirects can
  therefore combine frontend integration with data transfer in the
  background.

* Finally, there are various kinds of *transclusion*.  This involves
 combining the content of a website with the content of another
 website. This can be done either on the server or on the
 client. [Chapter 8](#chapter-links-javascript) shows an example where
 transclusion is implemented on the client with
 JavaScript. [Chapter 9](#chapter-esi), on the other hand, shows
 transclusion on the server side with ESI (edge-side includes).  The
 blog article at <https://www.innoq.com/en/blog/transclusion/> gives
 an overview of further possibilities.

These options can of course all be combined with each other. However,
this leads to a high level of technical complexity. Therefore, you
should first try to get by with just links because they have a very
low complexity and only add more options if needed.

## 7.3 Resource-oriented Client Architecture (ROCA) {#section-frontend-roca}

Modularization and integration in the frontend have an impact on the
architecture and the technologies in the frontend. SPAs (Single Page
Apps) are not very
well suited for integration in the frontend. Therefore, the question
arises as to which frontend architecture is better suited for
integration.

ROCA ([Resource-oriented Client Architecture](http://roca-style.org/))
is an approach for implementing web applications. It focuses on
established technologies such as HTML and leads to an architecture
which comprises many benefits for frontend modularization and
integration.

#### ROCA Principles

ROCA has the following principles:

* The server adheres to the *REST* principles. All resources have an
  unambiguous URL. Links to web pages can be sent by e-mail and then
  accessed from any browser if the necessary authorizations are
  given. HTTP methods are used correctly. For example, GETs do not
  change data. The server is stateless.

* Resources identified by URLs can have *other representations*
  besides HTML such as JSON or XML. This means that the data is not
  only available to people, but applications can also access the
  information.

* All *logic* is on the *server*. Accordingly, JavaScript on the
 client only serves to optimize the user interface. The system should
 even be accessible by other clients as browser. Logic on the server
 is desirable for security reasons because the client could be
 manipulated. It also makes it easier to change the logic since it is
 implemented in one location. There is no need to update a large number
 of clients.

* The *authentication information* is included in the *HTTP request*.
 HTTP basic, digest, client certificates or cookies can be used for
 this purpose.  In this way, authentication and authorization can take
 place solely on the basis of information contained in the HTTP
 request. Therefore, no server-side session is required for the
 authentication information.

* *Cookies* may only be used for authentification, tracking or as
  protection against cross site request forgery. Therefore, they may
  not contain business information.

* There must *not* be any *server-side session*. The use of sessions
 contradicts the ideas of HTTP because the communication is
 then no longer stateless.  This condition makes it difficult to
 implement failover and load balancing. The only exception is data that
 is required for authentication purposes in addition to the
 authentication information in the HTTP request.

* The *browser controls* such as the back, forward, or refresh button
 should work. This should be a matter of course, but many web
 applications with JavaScript logic have difficulties with it or have
 to do a lot of work in order to ensure the functioning of these
 buttons.

* The *HTML* may *not* contain *layout information* and should be
  accessible via a screen reader. The layout is defined by CSS so that
  layout and content are separate.

* JavaScript can be used, however, only in the form of *progressive
  enhancement*.  The application can even be used without JavaScript
  -- just not as easily and comfortably.
  The goal is not to avoid JavaScript completely but to still rely on
  the fundamental architecture and technologies of the web - HTTP,
  HTML and CSS.

* *Logic* must *not* be implemented *redundantly* on client and
  server.  Since the business logic is implemented on the server, it
  thus must not be implemented once again on the client.

In the end, ROCA applications are perfectly normal web applications.
They use the web principles as they were originally intended.

#### Benefits of the ROCA Architecture

ROCA has a number of advantages:

* The applications have a *clean architecture*. The logic is on the
 server.  Changes to the logic can easily be rolled out by a new
 server version.

* All *features of the web* can also be used. URLs can be sent to
  other people e.g. by e-mail because they uniquely identify
  resources. HTTP caches can be used because, for example, HTTP GETs
  are not allowed to change data. Optimizations in the browsers are
  exploited.
  Browsers implement many tricks
  to show users the first parts of a website as quickly as
  possible and to allow interactions with the website as soon as
  possible.

 * The applications get by with *little bandwidth* since there is
 hardly any need to transfer more than HTML, and only for the web
 pages that are actually visited. In an SPA, often the entire application
 must be transferred before any interaction is possible at all.
 Modern SPA technologies optimize this by loading separate modules
 instead of all the code. However, there is still some time it takes
 to initialize the application and make it react to user
 interaction. This is typically easier with a simple web application.
 Modern browser are optimized to make user interaction with simple web
 applications as fast and responsive as possible.

* In addition, the solution is *fast*. Especially for mobile devices,
  the speed of JavaScript implementations often leaves much to be
  desired. ROCA applications require a minimum of JavaScript.

* Finally, an *error in JavaScript* or in the transfer of the
 JavaScript code due to a problem on the network only leads to the
 application not being so easy to use. But it is still available. If
 logic were implemented in JavaScript, this would not be the case and
 the application would have less resilience.

* Even users having *JavaScript switched off* can still use the
 application.  Nowadays, however, such users are practically
 non-existent so that this advantage is irrelevant.

#### ROCA vs SPAs

ROCA is an alternative to SPAs (Single Page Apps) where the browser
is only used to execute JavaScript code. ROCA takes advantage of the
browser's optimizations for HTML and HTTP and also of the other
advantages of a real web application. Of course, a ROCA system can
also use JavaScript as discussed above.
The goal of ROCA is not to avoid JavaScript completely but to limit it
to areas where it makes sense or where there are no alternatives.

SPAs might be a better fit for complex UI e.g. games or map
applications on the web. However, for other types of application
e.g. e-commerce application SPAs do not just provide unneeded
flexibility but in fact they make it harder to achieve some features
like easily like search engine optimizations (SEO). So for a lot of
applications SPAs are actually not that great a fit.

SPAs seduces developers to implement more logic on the client. While
this might make the system more responsive, it can also lead to
redundant implementation on client and server that are harder to
maintain. Also it is hard to export the logic in the SPA as REST
service so other clients can use.

[Chapter 8](#chapter-links-javascript) shows an example of a ROCA
application that is quite comfortable to use.

#### Integration Options

ROCA applies to good UI layer design generally. It makes sense as a
guideline for implementing browser applications, monolithic or
modularized. However, ROCA does facilitate a simplified integration.
HTML is the focus in
the frontend. JavaScript only serves to improve usability. Thus, the
system can be modularized by providing HTML pages with links to other
HTML pages that may originate from other microservices. Or the HTML
pages can even be composed of several parts. Each component can come
from a different microservice. 
So it is easy to modularize a ROCA UI.
Because ROCA supports all options for
frontend integration, ROCA is a good basis for frontend integration
and for a microservices architecture.

## 7.4 Challenges {#section-frontend-herausforderungen}

Frontend integration means that the frontend is composed of different
systems. This causes some challenges.

#### UI Infrastructure

For UI integration to work, some infrastructure has to be
provided. That might just be common CSS or some JavaScript code but it
can also include server infrastructure for server-side
transclusion. Also there might be a need for UI parts that do not
really belong to any specific microservices e.g. the home page or a
navigation bar. These have to be developed and maintained.

It is important not to put too much into the UI infrastructure. If
the microservice relies too much on the generic UI infrastructure, it
will depend heavily on it and that contradicts the goal of independent
development. UI integration leads to a certain degree of dependencies
on the code level which usually lead to tight coupling. So the
dependencies should be limited. For example it make little sense to
provide all the styling, UI frameworks and UI code for all
microservices in one single component. This would be a problem in
particular for a migration to new technologies as the technology stack.
The stack is the same for all microservices and it is therefore hard
to migrate stepwise to a new stack.


#### Uniform Look & Feel

For example, it is not quite so easy to achieve a uniform look & feel
and design of the overall application. A uniform look & feel is
usually associated with the sharing of artifacts. Multiple
microservices must share the CSS, fonts, or JavaScript code required
to implement the design.
[Section 2.2](#section-mikro-makro-technisch) has already
shown a solution based on
macro architecture.

#### Interfaces in Frontend Integration

Transclusion generates a subtle type of interface definition.
Normally, an interface is defined by data types and operations. This
is obviously not the case for frontend integration. Still, there is a
kind of interface definition. For example, HTML code has to integrate
itself into another page if it is displayed in another frontend. To do
this, it may be necessary to have common CSS classes. So all the
frontends
must possess the same CSS selectors. If JavaScript is used in the
displayed HTML, the common JavaScript code and the JavaScript
libraries used must 
be available in the other web pages. Overall, these requirements form
a kind of interface definition that ensures that HTML can actually be
displayed. When only links or redirects are used, this challenge does not
exist. Only the URL must be known. The linked page can use completely
different CSS and JavaScript. Transclusion therefore couples the
systems more strongly than links do.

#### UI Changes Impact Multiple Modules

If the changes to a system typically only require changes to the UI,
this can be more complicated with frontend modularization.  The code
for the UI is distributed across the different frontends so that a
change means that all frontends have to be modified. Therefore, if the
UI is constantly redesigned or if the CSS is constantly being changed,
then frontend modularization can increase the effort. However,
frontend modularization has an advantage, even in case of such changes. The
change can be made step-by-step by changing only one frontend at a
time. This can minimize the risk associated with changes.

In addition, changes that only take place in the UI should be far less
frequent than domain-based changes that affect all layers.
So while it is harder to change all of the UI, those kinds of changes
should be not too frequent. Making them harder and making more
frequent changes easier at the same time seem like a good trade-off.

## 7.5 Benefits {#section-frontend-vorteile}

Frontend integration offers a number of benefits which make the
approach attractive.

#### Loose Coupling

Integration in the frontend creates loose coupling. For example, if
links are used for integration, only a URL must be known to
integration. What is behind the URL and how the information is
displayed doesn't matter and can be changed without impacting other
frontends. So a change can be limited to one frontend, even if the
page looks completely different.

#### Logic and UI in one Microservice

This is advantageous from the architecture's point of view. All logic
for a certain functionality is implemented in a single microservice. For
example, a microservice can be responsible for maintaining and
displaying a to-do list, even if the list is displayed integrated in
the UI of another microservice. If you want to display additional
information in the to-do list, such as a priority, you can implement
the logic, persistence, and UI by changing only one microservice, even
if another microservice integrates the rendered to-do list.

#### Free Choice of Frontend Technologies

Another influencing factor for frontend integration are the frontend
technologies. Especially in frontend technologies there are many
innovations. There are constantly new JavaScript frameworks and new
ways to create beautiful and easy-to-use interfaces. An important
advantage of microservices is the freedom of technology. Each
microservice can choose its own technologies. If technology freedom
should also apply to the frontend, then each microservice must have
its own frontend that can use its own technology. For this, the
frontends must be integrated accordingly. In particular, as much care
as possible must be taken to ensure that integration does not restrict
the use of frontend technologies. For example, if the integration
forces a certain JavaScript library, this can limit the technology
selection because with JavaScript it is not possible to use another
version of this library in parallel. For example, the client-side
integration in [chapter 8](#chapter-links-javascript) requires that each
frontend uses a certain jQuery version or provides its own custom
code.

## 7.6 Variations {#section-frontend-variationen}

Especially self-contained systems (SCS) (see
[chapter 3](#chapter-scs)) focus on frontend integration.

The next chapters discuss the different variations for frontend
integration. [Chapter 8](#chapter-links-javascript) shows how links
and transclusion work on the client side. [Chapter 9](#chapter-esi)
demonstrates the integration on the server side with ESI (Edge-Side
Includes).

Typically, a microservices system also uses synchronous communication
([chapter 13](#chapter-synchron)) or asynchronous communication
([chapter 10](#chapter-asynchron)) in addition to frontend
integration. The use of several integration approaches is common and
easily possible.

Ultimately, the browser only needs to access the various backends via
HTTP. This means that frontend integration puts little constraints on
the technologies used.


## 7.7 Conclusion {#section-frontend-fazit}

In general, integration at the frontend level should always be
considered when possible.  Too often, microservices are only
implemented as an approach to the backend, although by focusing on the
frontend, the coupling can be looser, and the system can be simpler and
more flexible. It can also be ensured that the entire logic, including
the logic for the UI, is actually implemented in the microservice.

Frontend integration allows loose coupling of microservices.
Already the use of links and of some JavaScript code can be enough
to integrate the frontends of different microservices. It is therefore
important not to immediately define a complex technology stack, but to
first find out what can be achieved by simple means. This leads to
another advantage. The technical complexity of the solution is not
particularly high. Only web applications are used. There are more of
them than usual,
but there are no new technologies.

But even when using server-side integration, the integration in the
frontend is still not particularly complex and still leads to a loose
coupling.
